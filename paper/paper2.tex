\documentclass[11pt]{article}

\usepackage{array}
\usepackage{clrscode3e}
\usepackage{amsmath}
\usepackage{kbordermatrix}

\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

\begin{document}

\title{Efficient Calculation of Polynomial Features on Sparse Matrices}
\author{Andrew Nystrom}
\date{}

\maketitle

\begin{abstract}%   <- trailing '%' for backward compatibility of .sty file
FILL THIS IN
\end{abstract}

\section{Introduction}
When performing a modeling task, one is often faced with a non-linearly separable problem,
or is attempting to predict a target that is a non-linear combination of the variables at one's disposal.
There are several general classes of methods for dealing with these situations: kernel methods, 
high variance models, and input transformations.

Of the possible types of input transformations one
might apply, a widely used method is the polynomial transformation, which is defined as 
all products of all combinations with replacement of $k$ components of a $D$ dimensional row vector $\vec{x}$ (assuming row-wise instance representation), where $k$ is the degree of the polynomial.
In the case of $k=2$, the following set of polynomial features are augmented to each $\vec{x}_i$:

\begin{equation}
\{x_a \cdot x_b : a, b \in \{0,1,..., D-1\} \land a \le b\}
\end{equation}

which results in $\binom{D+1}{D-1}$ additional features, and so the generation of 
these features has a time complexity of $O(D^2)$. In the general case of degree $k$, there 
are $\binom{D+k-1}{D-1}$ polynomial features and the time complexity is $O(D^k)$.

If the vectors of a feature matrix are sparse, many of these products of features will be
zero, and are therefore unnecessary to calculate if the matrix is stored in a sparse matrix 
data structure. If the density (the fraction of nonzero elements) of the matrix is $d$,
the number of nonzero polynomial features is

\begin{equation}
\binom{dD+2-1}{dD-1} = \frac{d^2D^2+dD}{2}
\end{equation}

and if only they were calculated, the time complexity of generating polynomial features
would be $O(d^2D^2)$, quadratically lower than calculating them via brute force.

The question then is how to devise an algorithm to calculate polynomial features for a vector $\vec{x}$ so that
only the nonzero elements of $\vec{x}$ are considered. Two main components are needed: (1) the ability to
quickly access the nonzero elements of $\vec{x}$ and (2) The ability to know which polynomial feature column
the product of features with indices $a$ and $b$ should be stored in.

Motivation for the need for (2) is not obvious. To make this need more clear, consider the
algorithm for the brute force calculation of polynomial features:

\begin{codebox}
\Procname{$\proc{Dense Polynomial Features}(\vec{x})$}
    \zi $D \gets |\vec{x}|$
    \zi $b$ $\gets$ vector of size $\frac{D^2+D}{2}$
    \zi $k \gets 0$
    \zi \For $\i \gets 0 \To D$ \Do
    \zi     \For $\j \gets i \To D$ \Do
    \zi         $\vec{b}[k] \gets \vec{x}[i] \cdot \vec{x}[j]$
    \zi         $k \gets k + 1$
            \End
        \End
    \End
    return $\vec{x} | \vec{b}$
\end{codebox}

Notice that the way the column the polynomial feature between features $i$ and $j$ can be determined
by a simple counter $k$ that is incremented each pass through the inner loop. This cannot be
done if we only calculate products between nonzero elements of $\vec{x}$, because all that
will be known is the nonzero element indices - many iterations will be skipped (hence the improved computational complexity).

What is therefore needed is a mapping between column index pairs of $\vec{x}$ and the space ${0, 1, ..., \binom{D+1}{D-1}-1}$
(the output size of second degree polynomial features when $D = |\vec{x}|$. The ordering of the mapping is irrelevant so long as
it its input $ I = {(a, b) : a, b \in \{0,1,..., D-1\} \land a \le b}$ is bijective with its output, ${0, 1, ..., \binom{D+1}{D-1}-1}$.

To construct this mapping, consider a matrix of size $D \times D$ where cell $(a,b)$ represents the
polynomial feature between indices $a$ and $b$ for $a,b \in I$ for vector $\vec{x}$.

\renewcommand{\kbldelim}{(}% Left delimiter
\renewcommand{\kbrdelim}{)}% Right delimiter
\[
  \kbordermatrix{
            & x_0 & x_1   & \cdot   & \cdot   &  \cdot  &  x_{D-1} \\
    x_0     & 0   & 1     & \cdot   &  \cdot  &  \cdot  &  D-1     \\
    x_1     & -   & D     & \cdot   &  \cdot  &  \cdot  &  2D-2    \\
     \cdot     & \cdot  & \cdot    &  \cdot  &      &      &  \cdot       \\
     \cdot     & \cdot  &       &  \cdot  &  \cdot  &      &  \cdot       \\
     \cdot     & \cdot  &       &      &  \cdot  &  \cdot  &  \cdot       \\
    x_{D-1} & -   & \cdot    &  \cdot  & \cdot   & -    &  \frac{D(D+1)}{2}-1\\
  }
\]

This is a rather natural sequencial ordering on both the input and output spaces. As can 
be seen, the required mapping can e viewed as mapping the upper triangular matrix (including 
the diagonal) to $0, 1, ..., \frac{D(D+1)}{2}-1$. The construction of this mapping will now
be given.
    
\vskip 0.2in
\bibliography{sample}

\end{document}